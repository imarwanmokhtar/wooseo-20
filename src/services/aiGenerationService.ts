
import { Product, SeoContent } from '@/types';
import { supabase } from "@/integrations/supabase/client";
import { modelConfig } from '@/components/ModelSelector';
import type { AIModel } from '@/components/ModelSelector';

export const DEFAULT_PROMPT_TEMPLATE = 
`You are an expert eCommerce SEO product description writer specializing in optimizing product content for RankMath SEO plugin. Your task is to write detailed and SEO-optimized product descriptions that achieve high RankMath scores.

CRITICAL RankMath SEO Requirements:
- Keep keyword density between 0.5% - 1.5% (avoid over-optimization)
- SEO Title MUST start with the Primary Focus Keyword exactly and MUST NOT end with a colon
- Permalink MUST start with the Primary Focus Keyword and MUST be under 50 characters
- Content MUST be at least 600 words to meet RankMath requirements
- Include 3-5 internal product links using format: {{store_url}}/product/product-name
- Include 2-3 internal category links using format: {{store_url}}/product-category/category-name
- Content should be clean HTML without Markdown formatting
- Use Focus Keywords naturally and sparingly (max 1.5% density)

Product Information:
Product Name: {{name}}
SKU: {{sku}}
Price: {{price}}
Description: {{description}}
Categories: {{categories}}
Store URL: {{store_url}}

INTERNAL LINKS STRATEGY:
Create relevant internal links using these patterns:
- Product links: {{store_url}}/product/related-product-name (example: {{store_url}}/product/samsung-galaxy-s24, {{store_url}}/product/iphone-15-pro)
- Category links: {{store_url}}/product-category/category-slug (example: {{store_url}}/product-category/smartphones, {{store_url}}/product-category/electronics)
- Make links contextually relevant and natural within the content flow

FOCUS KEYWORDS INSTRUCTION:
You MUST extract EXACTLY THREE focus keywords from the product name "{{name}}". 
DO NOT use "Generated by AI" or any placeholder text.
Analyze the product title and extract the main components as exactly 3 comma-separated keywords:

For example:
- If product name is "Infinix Smart 9 (RAM: 3+3) 6GB, ROM: 64GB" → Focus Keywords: "infinix smart 9, smart 9 smartphone, infinix smartphone"
- If product name is "Samsung Galaxy S24 Ultra 256GB" → Focus Keywords: "samsung galaxy s24, galaxy s24 ultra, samsung smartphone"
- If product name is "Apple MacBook Pro 16 inch" → Focus Keywords: "macbook pro, apple macbook, 16 inch laptop"

Content Requirements:
1. Long Description (600+ words minimum, HTML format):
   - Start with the Primary Focus Keyword naturally (not forced)
   - Use each Focus Keyword ONLY 2-3 times throughout the entire content (maintain low density)
   - Include detailed and informative content optimized for SEO
   - Use <strong> tags sparingly for highlighting important features (not keywords)
   - Include Focus Keywords in subheadings (<h2>, <h3>, <h4>) naturally
   - Include a comprehensive Product Information Table (Size, Color, Material, Brand Name, Specifications)
   - Include detailed Key Features and Benefits sections
   - Add comprehensive product overview and usage instructions
   - Answer 2-3 frequently searched questions related to the product
   - Include product care and maintenance instructions
   - Add warranty and guarantee information
   - Use emoticons/icons sparingly to evoke emotional connection
   - Include 3-4 INTERNAL product links naturally integrated in text: <a href="{{store_url}}/product/related-product-name">Related Product Name</a>
   - Include 2-3 INTERNAL category links naturally in text: <a href="{{store_url}}/product-category/category-name">Category Name</a>
   - Avoid keyword stuffing - focus on natural, helpful content
   - Distribute keywords evenly throughout content, not concentrated in one area

2. Short Description (50 words max):
   - Concise and engaging, highlighting uniqueness and key features
   - Use Primary Focus Keyword ONCE only
   - Provided as plain text without any Markdown formatting

3. SEO Elements (Optimized for Rank Math SEO Plugin):
   - SEO Meta Title: MUST start with the exact Primary Focus Keyword, be under 60 characters, include a power word and a number, and MUST NOT end with a colon
   - SEO Permalink: MUST start with the Primary Focus Keyword and be URL-friendly, MAXIMUM 40 CHARACTERS (keep it short)
   - Meta Description: 140-155 characters, must include the Primary Focus Keyword ONCE, with a call to action
   - Focus Keywords: Extract EXACTLY THREE focus keywords from the product name "{{name}}". Format as comma-separated values. NEVER use "generated by ai" or similar placeholder text.
   - Image Alt Text: Create descriptive alt text for the main product image using the product name and key features (under 125 characters)

KEYWORD DENSITY CONTROL:
- Primary Focus Keyword: Use maximum 8-10 times in 600+ words (1.5% density)
- Secondary Focus Keywords: Use maximum 4-6 times each
- Distribute keywords naturally throughout headings, body text, and alt text
- Focus on synonyms and related terms instead of repeating exact keywords
- Prioritize readability and value over keyword repetition

INTERNAL LINKING EXAMPLES:
- "Explore our wide range of <a href="{{store_url}}/product-category/smartphones">smartphones</a> for more options."
- "You might also be interested in the <a href="{{store_url}}/product/samsung-galaxy-s23">Samsung Galaxy S23</a> for a similar experience."
- "Check out our <a href="{{store_url}}/product-category/electronics">electronics collection</a> for complementary products."

Output MUST include these EXACT section headers in your response:
LONG DESCRIPTION:
SHORT DESCRIPTION:
META TITLE:
META DESCRIPTION:
FOCUS KEYWORDS:
IMAGE ALT TEXT:
PERMALINK:

Do not include any Markdown formatting like \`\`\` or ** in your output.`;

export async function savePromptTemplate(userId: string, name: string, content: string) {
  const { data, error } = await supabase
    .from('prompt_templates')
    .insert({
      user_id: userId,
      name,
      template: content,
    })
    .select('*')
    .single();

  if (error) throw error;
  return data;
}

export async function getPromptTemplates(userId: string) {
  const { data, error } = await supabase
    .from('prompt_templates')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false });

  if (error) throw error;
  return data;
}

export async function generateSeoContent(
  product: Product,
  prompt: string,
  userId: string,
  model: AIModel = 'gemini-2.0-flash',
  storeId?: string
): Promise<SeoContent> {
  console.log('Starting SEO content generation for product:', product.name, 'with model:', model, 'for store:', storeId);

  // Get store URL and credentials for the specific active store
  const { data: storeData, error: storeError } = await supabase
    .from('woocommerce_credentials')
    .select('store_url, consumer_key, consumer_secret')
    .eq('user_id', userId)
    .eq('id', storeId) // Use the specific store ID, not just is_active
    .single();

  if (storeError || !storeData) {
    console.error('Error fetching store data:', storeError);
    throw new Error('Could not find store credentials. Please ensure your store is properly connected.');
  }

  const storeUrl = storeData.store_url;
  console.log('Using actual store URL for internal links:', storeUrl);

  // Fetch real categories and products for link examples
  let categoryExamples = '';
  let productExamples = '';

  if (storeData.consumer_key && storeData.consumer_secret) {
    try {
      const auth = btoa(`${storeData.consumer_key}:${storeData.consumer_secret}`);
      
      // Fetch actual categories from the store
      console.log('Fetching real categories from store...');
      const categoriesResponse = await fetch(`${storeUrl}/wp-json/wc/v3/products/categories?per_page=20`, {
        headers: {
          Authorization: `Basic ${auth}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (categoriesResponse.ok) {
        const categories = await categoriesResponse.json();
        console.log('Found categories:', categories.length);
        const categoryLinks = categories
          .filter((cat: any) => cat.count > 0) // Only categories with products
          .slice(0, 8)
          .map((cat: any) => `${storeUrl}/product-category/${cat.slug}`);
        
        if (categoryLinks.length > 0) {
          categoryExamples = `\n\nYOUR ACTUAL STORE CATEGORY LINKS TO USE:\n${categoryLinks.join('\n')}`;
          console.log('Category examples to include:', categoryExamples);
        }
      } else {
        console.log('Failed to fetch categories:', categoriesResponse.status);
      }

      // Fetch actual products from the store
      console.log('Fetching real products from store...');
      const productsResponse = await fetch(`${storeUrl}/wp-json/wc/v3/products?per_page=15&status=publish`, {
        headers: {
          Authorization: `Basic ${auth}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (productsResponse.ok) {
        const products = await productsResponse.json();
        console.log('Found products:', products.length);
        const productLinks = products
          .filter((prod: any) => prod.status === 'publish' && prod.slug) // Only published products with slugs
          .slice(0, 8)
          .map((prod: any) => `${storeUrl}/product/${prod.slug}`);
        
        if (productLinks.length > 0) {
          productExamples = `\n\nYOUR ACTUAL STORE PRODUCT LINKS TO USE:\n${productLinks.join('\n')}`;
          console.log('Product examples to include:', productExamples);
        }
      } else {
        console.log('Failed to fetch products:', productsResponse.status);
      }
    } catch (error) {
      console.error('Error fetching real store data for examples:', error);
    }
  }

  // Prepare the product data for the prompt with actual store data
  const categories = product.categories.map(cat => cat.name).join(', ');
  const formattedPrompt = prompt
    .replace(/\{\{name\}\}/g, product.name)
    .replace(/\{\{sku\}\}/g, product.sku)
    .replace(/\{\{price\}\}/g, product.price)
    .replace(/\{\{description\}\}/g, product.description)
    .replace(/\{\{categories\}\}/g, categories)
    .replace(/\{\{store_url\}\}/g, storeUrl) + categoryExamples + productExamples;

  console.log('Final prompt includes real store data:', {
    storeUrl,
    hasCategoryExamples: categoryExamples.length > 0,
    hasProductExamples: productExamples.length > 0
  });

  try {
    // First, check if the user has enough credits
    const { data: userData, error: userError } = await supabase
      .from('users')
      .select('credits')
      .eq('id', userId)
      .single();

    if (userError) {
      console.error('Error fetching user credits:', userError);
      throw new Error('Failed to verify user credits. Please try again.');
    }
    
    const requiredCredits = modelConfig[model].credits;
    
    if (!userData || userData.credits < requiredCredits) {
      throw new Error(`Not enough credits to generate content. This model requires ${requiredCredits} credits.`);
    }

    console.log('User has enough credits. Calling AI API...');
    
    // Call the edge function to generate content
    const { data, error } = await supabase.functions.invoke('generate-content', {
      body: {
        product,
        prompt: formattedPrompt,
        model,
        userId
      }
    });

    if (error) {
      console.error('Error from generate-content function:', error);
      throw new Error('Failed to generate content. Please try again.');
    }

    console.log('AI API response received');

    const seoContent = data;
    seoContent.product_id = product.id;
    seoContent.product_name = product.name;
    seoContent.user_id = userId;

    console.log('Parsed SEO content successfully:', seoContent);

    // Deduct credits from the user's account and update store credits
    const { error: updateError } = await supabase
      .from('users')
      .update({ credits: userData.credits - requiredCredits })
      .eq('id', userId);

    if (updateError) {
      console.error('Error updating user credits:', updateError);
      throw new Error('Failed to update credits. The content was generated but your credits were not deducted.');
    }

    // Update store credits if storeId is provided
    if (storeId) {
      console.log('Updating store credits for store:', storeId);
      
      // Get current store credits
      const { data: storeCreditsData, error: storeCreditsError } = await supabase
        .from('woocommerce_credentials')
        .select('used_credits')
        .eq('id', storeId)
        .eq('user_id', userId)
        .single();

      if (storeCreditsError) {
        console.error('Error fetching store credits:', storeCreditsError);
        // Don't throw here as the main operation succeeded
      } else {
        const currentUsedCredits = storeCreditsData?.used_credits || 0;
        const newUsedCredits = currentUsedCredits + requiredCredits;

        const { error: updateStoreError } = await supabase
          .from('woocommerce_credentials')
          .update({ used_credits: newUsedCredits })
          .eq('id', storeId)
          .eq('user_id', userId);

        if (updateStoreError) {
          console.error('Error updating store credits:', updateStoreError);
          // Don't throw here as the main operation succeeded
        } else {
          console.log(`Store credits updated: ${currentUsedCredits} -> ${newUsedCredits}`);
        }
      }
    }

    console.log(`SEO content generated successfully and ${requiredCredits} credits deducted`);

    return seoContent;
  } catch (error) {
    console.error('Error generating SEO content:', error);
    throw error instanceof Error ? error : new Error('Unknown error generating content');
  }
}

export async function getSeoHistoryForProduct(userId: string, productId: number) {
  // This function is no longer functional since we removed the generated_content table
  console.warn('getSeoHistoryForProduct is no longer available - generated_content table was removed');
  return [];
}
